# Copyright (c) 2021-2025 Arm Limited.
# SPDX-License-Identifier: Apache-2.0
"""Setup script for backward compatibility."""
import multiprocessing
import os
import shutil
import subprocess
import sys
from pathlib import Path

from setuptools import setup
from setuptools.command.build_py import build_py


# On "pip install", we compile the project with CMake to build the reference model
# .so file generated by Pybind. Then, we copy the .so to the py_package/ directory,
# which setup.cfg lists as a package_dir
# Use pip install -v to see extra debug info in prints.
class CMakeBuild(build_py):
    def run(self):
        root_dir = Path(__file__).parent
        build_dir = root_dir / "build"
        build_dir.mkdir(exist_ok=True)
        package_dir = root_dir / "py_package"

        cmake_cmd = [
            "cmake",
            "-DCMAKE_BUILD_TYPE=Release",
            "-DBUILD_TOSA_REFERENCE_MODEL_PYBIND=ON",
            "..",
        ]
        generator_flags = ["-GNinja", "-UCMAKE_GENERATOR"]
        build_cmd = ["cmake", "--build", "."]
        build_cmd.append(f"-j{round(multiprocessing.cpu_count() * 0.7)}")

        print(f"Configuring cmake from build dir '{build_dir}'.")

        for generator_flag in generator_flags:
            print(f"Attempting to configure cmake using generator {generator_flag}")
            try:
                subprocess.run(
                    cmake_cmd + [generator_flag],
                    cwd=build_dir,
                    check=True,
                    capture_output=True,
                )
                print(
                    f"Configured cmake for building reference_model using generator {generator_flag}"
                )
                break
            except subprocess.CalledProcessError as e:
                # Only raise error if fail at last generator attempt.
                if generator_flag == generator_flags[-1]:
                    error_message = (
                        f"Failed configuring cmake with any of the following generator settings: {generator_flags}."
                        + f"\nStdout from last attempt:\n{e.stdout.decode()}"
                        + f"\nStderr from last attempt:\n{e.stderr.decode()}"
                        + "\nIf this error is due to the ninja module not being found, try pip uninstalling ninja."
                    )
                    raise RuntimeError(error_message) from e
                else:
                    print(f"Stderr for generator flag: {generator_flag}")
                    print(e.stderr.decode())
                    print("Continuing with next generator...")
            except ImportError as e:
                # Only raise error if fail at last generator attempt.
                if generator_flag == generator_flags[-1]:
                    raise RuntimeError(
                        "If this error is due to the ninja module not being found, try pip uninstalling ninja."
                    ) from e
                else:
                    print(
                        f"The python subprocess failed to find a module in your environment for generator {generator_flag}."
                    )
                    print(e)
                    print("Continuing with next generator...")

        try:
            print("Building reference_model...")
            subprocess.run(
                build_cmd,
                cwd=build_dir,
                check=True,
                stdout=sys.stdout,
                stderr=subprocess.STDOUT,
            )
        except subprocess.CalledProcessError as e:
            raise RuntimeError("Failed building reference_model.") from e

        # There should only be one of these but supporting multiple is fine,
        # Python will know which one to import
        shared_lib_ext = ".pyd" if sys.platform.startswith("win") else ".so"
        shared_lib_pattern = f"tosa_reference_model.*{shared_lib_ext}"

        shared_lib_paths = list(build_dir.rglob(shared_lib_pattern))
        print(f"Copying shared libraries from '{build_dir}' to '{package_dir}'")

        if not shared_lib_paths:
            raise RuntimeError(
                f"No shared library matching '{shared_lib_pattern}' found in '{build_dir}'"
            )

        for shared_lib_path in shared_lib_paths:
            print(f"Copying {shared_lib_path} to {package_dir}")
            shutil.copy(shared_lib_path, package_dir)

        build_py.run(self)


build_pybind = os.getenv("BUILD_PYBIND", "0") == "1"
if build_pybind:
    setup(cmdclass={"build_py": CMakeBuild})
else:
    setup()
