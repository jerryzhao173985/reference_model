
// Copyright (c) 2022-2023, ARM Limited.
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

// THIS FILE IS GENERATED. DO NOT EDIT!
// See scripts/operator_api/generate_api.py

#include "operators.h"
#include "model_runner_impl.h"
#include "ops/op_factory.h"


#define TOSA_PROPAGATE_ERROR(status)                                                                                   \
    do                                                                                                                 \
    {                                                                                                                  \
        if (status != 0)                                                                                               \
        {                                                                                                              \
            return status;                                                                                             \
        }                                                                                                              \
    } while (false)


#define TOSA_RETURN_ON_ERROR(status)                                                                                   \
    do                                                                                                                 \
    {                                                                                                                  \
        if (status != 0)                                                                                               \
        {                                                                                                              \
            return tosa_status_error;                                                                                  \
        }                                                                                                              \
    } while (false)

#define TOSA_RETURN_ON_GRAPH_STATUS_ERROR(status)                                                                      \
    do                                                                                                                 \
    {                                                                                                                  \
        if (status != GraphStatus::TOSA_VALID)                                                                         \
        {                                                                                                              \
            auto ustatus = static_cast<std::underlying_type_t<GraphStatus>>(status);                                   \
            return static_cast<tosa_status_t>(ustatus);                                                                \
        }                                                                                                              \
    } while (false)

namespace {

tosa::DType translate_client_datatype(tosa_datatype_t type)
{
    switch (type)
    {
        case tosa_datatype_bf16_t:
            return tosa::DType::DType_BF16;
        case tosa_datatype_bool_t:
            return tosa::DType::DType_BOOL;
        case tosa_datatype_fp16_t:
            return tosa::DType::DType_FP16;
        case tosa_datatype_fp32_t:
            return tosa::DType::DType_FP32;
        case tosa_datatype_int16_t:
            return tosa::DType::DType_INT16;
        case tosa_datatype_int32_t:
            return tosa::DType::DType_INT32;
        case tosa_datatype_int48_t:
            return tosa::DType::DType_INT48;
        case tosa_datatype_int4_t:
            return tosa::DType::DType_INT4;
        case tosa_datatype_int8_t:
            return tosa::DType::DType_INT8;
        case tosa_datatype_uint16_t:
            return tosa::DType::DType_UINT16;
        case tosa_datatype_uint8_t:
            return tosa::DType::DType_UINT8;
        case tosa_datatype_shape_t:
            return tosa::DType::DType_SHAPE;
        default:
            return tosa::DType::DType_UNKNOWN;
    }
};

using TosaTensorInfo = std::pair<tosa::TosaSerializationTensor*, tosa_tensor_t*>;

tosa::TosaSerializationTensor* translate_client_tensor(tosa_tensor_t& tensor, const std::string& name)
{
    std::vector<int32_t> shape(tensor.shape, tensor.shape + tensor.num_dims);
    return new tosa::TosaSerializationTensor(name, shape, translate_client_datatype(tensor.data_type), {});
}

void addTensor(std::vector<TosaTensorInfo> &tensors, tosa_tensor_t& tensor, std::string tensorName) {
    auto tensorDescr = translate_client_tensor(tensor, tensorName);
    tensors.push_back(std::make_pair(tensorDescr, &tensor));
}

int setInputTensors(TosaReference::ModelRunnerImpl& runner, std::vector<TosaTensorInfo>& inputTensors)
{
    for (const auto& [tensorDescr, tensorData] : inputTensors)
    {
        auto status = runner.setInput(tensorDescr->GetName(), tensorData->data, tensorData->size);
        TOSA_PROPAGATE_ERROR(status);
    }

    return 0;
}

int getOutputTensors(TosaReference::ModelRunnerImpl& runner, std::vector<TosaTensorInfo>& outputTensors)
{
    for (const auto& [tensorDescr, tensorData] : outputTensors)
    {
        auto status = runner.getOutput(tensorDescr->GetName(), tensorData->data, tensorData->size);
        TOSA_PROPAGATE_ERROR(status);
    }

    return 0;
}

std::vector<std::string> getTensorNames(std::vector<TosaTensorInfo>& tensors)
{
    std::vector<std::string> tensorNames;
    const auto mapping = [](const TosaTensorInfo &info){ return info.first->GetName(); };

    std::transform(tensors.cbegin(), tensors.cend(), std::back_inserter(tensorNames), mapping);
    return tensorNames;
}

std::vector<TosaSerializationTensor*> allTensors(std::vector<TosaTensorInfo> &inputTensors, std::vector<TosaTensorInfo> &outputTensors) {
    std::vector<TosaSerializationTensor*> result;
    const auto mapping = [](const TosaTensorInfo &info){ return info.first; };

    std::transform(inputTensors.cbegin(), inputTensors.cend(), std::back_inserter(result), mapping);
    std::transform(outputTensors.cbegin(), outputTensors.cend(), std::back_inserter(result), mapping);

    return result;
}

tosa::ResizeMode translate_client_tosa_mode(tosa_mode_t mode) {
    switch(mode) {
        case tosa_mode_nearest:
            return tosa::ResizeMode_NEAREST;
        case tosa_mode_max:
        case tosa_mode_bilinear:
            return tosa::ResizeMode_BILINEAR;
        default:
            return tosa::ResizeMode_UNKNOWN;
    }
}

tosa::DType translate_client_acc_size(tosa_acc_size_t acc_size) {
    switch(acc_size) {
        case tosa_acc_size_int32_t:
            return tosa::DType::DType_INT32;
        case tosa_acc_size_fp16_t:
            return tosa::DType::DType_FP16;
        case tosa_acc_size_fp32_t:
            return tosa::DType::DType_FP32;
        default:
            return tosa::DType::DType_UNKNOWN;
    }
}

}    // namespace

extern "C"
{
    {% for operator in operators: %}
    tosa_status_t tosa_run_{{ operator.name }} (
        {%- for arg in operator.arguments: -%}
            {% if arg.type != "tosa_tensor_t" -%}const {% endif -%}{{arg.type}} client_{{arg.name}}{{arg.shape}}
            {% if not loop.last %},{% endif %}
        {%- endfor -%},const func_ctx_t& func_ctx
    )
    {
        // Create operator attributes
        {% for att in operator.serialLibAtts: -%}
            {{att.init}}
        {%- endfor -%}

        Tosa{{operator.serializeAttType}}Attribute attr
        {%- if operator.serialLibAtts|length > 0 -%}
        (
            {%- for att in operator.serialLibAtts: -%}
                {%- if att.init == "" -%}
                    client_{{att.name}}
                {%- else -%}
                    {{att.name}}
                {%- endif -%}
                {% if not loop.last %}, {% endif %}
            {%- endfor -%}
        )
        {%- endif -%};

        // Create tensors
        std::vector<TosaTensorInfo> inputTensors;
        {% for input in operator.inputs: -%}
            {%- if input.type == "tosa_tensor_list_t" -%}
                for (int i = 0; i < client_{{input.name}}.size; i++) {
                    addTensor(inputTensors, client_{{input.name}}.tensors[i], "{{input.name}}-" + std::to_string(i));
                }
            {%- else -%}
                addTensor(inputTensors, client_{{input.name}}, "{{input.name}}");
            {%- endif -%}
        {%- endfor %}

        std::vector<TosaTensorInfo> outputTensors;
        {% for output in operator.outputs: -%}
            addTensor(outputTensors, client_{{output}}, "{{output}}");
        {%- endfor %}

        // Create operator
        auto op = new tosa::TosaSerializationOperator(tosa::Op::Op_{{operator.name|upper}},
                                                      {%- if operator.serializeAttType != "None" -%}
                                                        tosa::Attribute::Attribute_{{operator.serializeAttType}}Attribute
                                                      {%- else -%}
                                                        tosa::Attribute::Attribute_NONE
                                                      {%- endif -%},
                                                      &attr,
                                                      getTensorNames(inputTensors),
                                                      getTensorNames(outputTensors));

        // Create a tosa single-op basic block
        tosa::TosaSerializationBasicBlock block("{{operator.name}}", "main", { op },
                                                 allTensors(inputTensors, outputTensors),
                                                 op->GetInputTensorNames(),
                                                 op->GetOutputTensorNames());

        // Setup model
        TosaReference::ModelRunnerImpl runner(func_ctx.func_config, func_ctx.func_debug);
        TOSA_RETURN_ON_GRAPH_STATUS_ERROR(runner.initialize(block));

        TOSA_RETURN_ON_ERROR(setInputTensors(runner, inputTensors));

        // Execute
        TOSA_RETURN_ON_GRAPH_STATUS_ERROR(runner.run());

        // Extract outputs
        TOSA_RETURN_ON_ERROR(getOutputTensors(runner, outputTensors));

        return tosa_status_valid;
    }
    {% endfor %}

}    // extern "C"